{% extends "base.html" %}

{% block content %}
<style>
    header {
        display: none;
    }
</style>

<div class="detail-header">
    <a href="{{ url_for('index') }}" class="back-link">← Back</a>
    <button class="edit-habit-btn" onclick="openEditModal()">Edit Habit</button>
</div>

<div class="habit-detail-container">
    <div class="habit-detail-title-row">
        <form method="POST" action="{{ url_for('toggle_habit', habit_id=habit.habit_id) }}" style="margin: 0;" onsubmit="return false;">
            <input type="hidden" name="next" value="{{ url_for('habit_detail', habit_id=habit.habit_id) }}">
            <input type="checkbox"
                   class="detail-habit-checkbox"
                   {% if habit.completed_today %}checked{% endif %}
                   onchange="toggleHabit({{ habit.habit_id }}, this)">
        </form>
        <h1 class="habit-detail-title">{{ habit.habit_name }}</h1>
    </div>

<!-- Edit Modal -->
<div id="editModal" class="modal" onclick="closeModalOnBackdrop(event)">
    <div class="modal-content modal-content-wide" onclick="event.stopPropagation()">
        <button type="button" class="modal-close" onclick="closeEditModal()">×</button>
        <form id="renameForm" method="POST" action="{{ url_for('rename_habit_route', habit_id=habit.habit_id) }}">
            <label for="habit_name">Habit Name</label>
            <input
                type="text"
                id="habit_name"
                name="habit_name"
                value="{{ habit.habit_name }}"
                required
                autofocus
                onblur="saveHabitName()"
            >
        </form>

        <!-- Historical Date Editor -->
        <div class="history-editor-section">
            <h3 class="history-editor-title">Edit Habit History</h3>

            <!-- Calendar Navigation Controls -->
            <div class="calendar-nav">
                <button type="button" class="calendar-nav-btn" onclick="prevMonth()">‹</button>

                <div class="calendar-nav-selects">
                    <select id="calendarMonth" class="calendar-select" onchange="updateCalendar()">
                        <!-- Populated by JavaScript -->
                    </select>
                    <select id="calendarYear" class="calendar-select" onchange="updateCalendar()">
                        <!-- Populated by JavaScript -->
                    </select>
                </div>

                <button type="button" class="calendar-nav-btn" onclick="nextMonth()">›</button>
            </div>

            <!-- Calendar Grid -->
            <div class="calendar-wrapper">
                <!-- Day of week headers -->
                <div class="calendar-weekdays">
                    <span>Sun</span><span>Mon</span><span>Tue</span><span>Wed</span>
                    <span>Thu</span><span>Fri</span><span>Sat</span>
                </div>

                <!-- Calendar days grid (populated by JavaScript) -->
                <div id="calendarGrid" class="calendar-grid">
                    <!-- Days will be dynamically generated -->
                </div>
            </div>
        </div>

        <div class="delete-section">
            <form method="POST" action="{{ url_for('delete_habit_route', habit_id=habit.habit_id) }}"
                  onsubmit="return confirm('Delete {{ habit.habit_name }}? All historical data will be preserved.')">
                <button type="submit" class="btn btn-delete">Delete Habit</button>
            </form>
        </div>
    </div>
</div>

<script>
let originalHabitName = '';
let currentHabitId = null;
let currentViewDate = null;  // Date object for calendar view
let habitHistory = [];  // Store 100-day history from server

function openEditModal() {
    const modal = document.getElementById('editModal');
    modal.style.display = 'flex';

    // Store original habit name
    const habitInput = document.getElementById('habit_name');
    originalHabitName = habitInput.value;

    // Store habit ID for calendar
    currentHabitId = {{ habit.habit_id }};

    // Store habit history (last 100 days, index 0 = today)
    habitHistory = {{ habit.history|tojson }};

    // Initialize calendar to current month
    currentViewDate = new Date();

    // Populate month/year dropdowns
    populateMonthDropdown();
    populateYearDropdown();

    // Render initial calendar
    renderCalendar();
}

// Populate month dropdown (0-11)
function populateMonthDropdown() {
    const select = document.getElementById('calendarMonth');
    const months = ['January', 'February', 'March', 'April', 'May', 'June',
                    'July', 'August', 'September', 'October', 'November', 'December'];

    select.innerHTML = months.map((month, i) =>
        `<option value="${i}" ${i === currentViewDate.getMonth() ? 'selected' : ''}>${month}</option>`
    ).join('');
}

// Populate year dropdown (current year down to 2 years ago)
function populateYearDropdown() {
    const select = document.getElementById('calendarYear');
    const currentYear = new Date().getFullYear();
    const years = [];

    for (let year = currentYear; year >= currentYear - 2; year--) {
        years.push(year);
    }

    select.innerHTML = years.map(year =>
        `<option value="${year}" ${year === currentViewDate.getFullYear() ? 'selected' : ''}>${year}</option>`
    ).join('');
}

// Navigate to previous month
function prevMonth() {
    currentViewDate.setMonth(currentViewDate.getMonth() - 1);

    // Update dropdowns
    document.getElementById('calendarMonth').value = currentViewDate.getMonth();
    document.getElementById('calendarYear').value = currentViewDate.getFullYear();

    renderCalendar();
}

// Navigate to next month
function nextMonth() {
    const today = new Date();

    // Don't allow navigating past current month
    if (currentViewDate.getFullYear() === today.getFullYear() &&
        currentViewDate.getMonth() === today.getMonth()) {
        return;
    }

    currentViewDate.setMonth(currentViewDate.getMonth() + 1);

    // Update dropdowns
    document.getElementById('calendarMonth').value = currentViewDate.getMonth();
    document.getElementById('calendarYear').value = currentViewDate.getFullYear();

    renderCalendar();
}

// Update calendar when dropdown changes
function updateCalendar() {
    const month = parseInt(document.getElementById('calendarMonth').value);
    const year = parseInt(document.getElementById('calendarYear').value);

    currentViewDate = new Date(year, month, 1);
    renderCalendar();
}

// Render the calendar grid for current month
function renderCalendar() {
    const grid = document.getElementById('calendarGrid');
    const year = currentViewDate.getFullYear();
    const month = currentViewDate.getMonth();

    // Get first day of month and number of days
    const firstDay = new Date(year, month, 1).getDay();
    const daysInMonth = new Date(year, month + 1, 0).getDate();

    // Get today's date for comparison
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // Get 2 years ago date for validation
    const twoYearsAgo = new Date();
    twoYearsAgo.setFullYear(twoYearsAgo.getFullYear() - 2);

    // Clear grid
    grid.innerHTML = '';

    // Add empty cells for days before month starts
    for (let i = 0; i < firstDay; i++) {
        const emptyCell = document.createElement('div');
        emptyCell.className = 'calendar-day empty';
        grid.appendChild(emptyCell);
    }

    // Add day cells
    for (let day = 1; day <= daysInMonth; day++) {
        const date = new Date(year, month, day);
        const dateStr = date.toISOString().split('T')[0];

        const dayCell = document.createElement('div');
        dayCell.className = 'calendar-day';

        // Check if date is in the future
        if (date > today) {
            dayCell.classList.add('future');
            dayCell.textContent = day;
        }
        // Check if date is older than 2 years
        else if (date < twoYearsAgo) {
            dayCell.classList.add('disabled');
            dayCell.textContent = day;
        }
        // Clickable date
        else {
            dayCell.textContent = day;
            dayCell.dataset.date = dateStr;

            // Check completion status from habit history
            const isComplete = checkDateStatus(date);
            if (isComplete) {
                dayCell.classList.add('complete');
            } else {
                dayCell.classList.add('incomplete');
            }

            // Add click handler
            dayCell.onclick = () => toggleCalendarDate(dateStr, dayCell);
        }

        grid.appendChild(dayCell);
    }
}

// Check if a date is completed (uses habit history for last 100 days)
function checkDateStatus(date) {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // Calculate days ago from today
    const daysAgo = Math.floor((today - date) / (1000 * 60 * 60 * 24));

    // If within 100-day history window, check the array
    if (daysAgo >= 0 && daysAgo < habitHistory.length) {
        return habitHistory[daysAgo];
    }

    // For dates outside the 100-day window, assume incomplete
    return false;
}

// Toggle completion for a calendar date
function toggleCalendarDate(dateStr, dayCell) {
    if (dayCell.classList.contains('future') || dayCell.classList.contains('disabled')) {
        return;  // Can't edit future or too-old dates
    }

    // Optimistic UI update
    const wasComplete = dayCell.classList.contains('complete');

    if (wasComplete) {
        dayCell.classList.remove('complete');
        dayCell.classList.add('incomplete');
    } else {
        dayCell.classList.remove('incomplete');
        dayCell.classList.add('complete');
    }

    // Get current trend period
    const trendPeriod = document.getElementById('trendPeriod').value;

    // Send AJAX request (reuse existing endpoint)
    fetch(`/toggle-habit/${currentHabitId}/date?period=${trendPeriod}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ date: dateStr })
    })
    .then(response => response.json())
    .then(data => {
        if (!data.success) {
            // Revert optimistic update on error
            if (wasComplete) {
                dayCell.classList.add('complete');
                dayCell.classList.remove('incomplete');
            } else {
                dayCell.classList.remove('complete');
                dayCell.classList.add('incomplete');
            }
            alert('Failed to update habit. Please try again.');
            return;
        }

        // Update local habit history array with new data from server
        habitHistory = data.updated_history;

        // Update the detail page count display
        const countElement = document.querySelector('.detail-count-main');
        if (countElement) {
            countElement.textContent = data.new_count;
        }

        // Update the detail page dot grid (outside modal)
        const detailDots = document.querySelectorAll('.detail-dot-grid .detail-dot');
        data.updated_history.forEach((completed, index) => {
            if (detailDots[index]) {
                if (completed) {
                    detailDots[index].classList.add('filled');
                } else {
                    detailDots[index].classList.remove('filled');
                }
            }
        });

        // Update the trend graph
        if (data.trend && data.month_labels) {
            updateTrendGraph(data.trend, data.month_labels);
        }
    })
    .catch(error => {
        // Revert optimistic update on error
        if (wasComplete) {
            dayCell.classList.add('complete');
            dayCell.classList.remove('incomplete');
        } else {
            dayCell.classList.remove('complete');
            dayCell.classList.add('incomplete');
        }
        alert('Failed to update habit. Please try again.');
    });
}

// Update the trend graph with new data
function updateTrendGraph(trendData, monthLabels) {
    const svg = document.getElementById('trendGraph');
    if (!svg || !trendData || trendData.length === 0) return;

    // Calculate x scale
    const x_scale = 600 / (trendData.length - 1);

    // Reverse the trend data (same as Jinja template does)
    const reversedTrend = trendData.slice().reverse();

    // Build polygon points for gradient fill
    let polygonPoints = '';
    reversedTrend.forEach((value, index) => {
        polygonPoints += `${index * x_scale},${300 - (value * 3)} `;
    });
    polygonPoints += '600,300 0,300';

    // Build polyline points for trend line
    let polylinePoints = '';
    reversedTrend.forEach((value, index) => {
        if (index > 0) polylinePoints += ' ';
        polylinePoints += `${index * x_scale},${300 - (value * 3)}`;
    });

    // Find and update polygon
    const polygon = svg.querySelector('polygon');
    if (polygon) {
        polygon.setAttribute('points', polygonPoints);
    }

    // Find and update polyline
    const polyline = svg.querySelector('polyline');
    if (polyline) {
        polyline.setAttribute('points', polylinePoints);
    }

    // Update month labels
    const existingLabels = svg.querySelectorAll('text[y="325"]');
    existingLabels.forEach(label => label.remove());

    monthLabels.forEach(labelData => {
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', labelData.x);
        text.setAttribute('y', '325');
        text.setAttribute('fill', '#ffffff');
        text.setAttribute('font-size', '16');
        text.setAttribute('font-family', 'Lora, serif');
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('opacity', '0.7');
        text.textContent = labelData.label;
        svg.appendChild(text);
    });
}

function closeEditModal() {
    // Save habit name if it changed before closing
    saveHabitName();
    document.getElementById('editModal').style.display = 'none';
}

function saveHabitName() {
    const habitInput = document.getElementById('habit_name');
    const newName = habitInput.value.trim();

    // Only submit if name changed and is not empty
    if (newName && newName !== originalHabitName) {
        originalHabitName = newName;
        document.getElementById('renameForm').submit();
    }
}

function closeModalOnBackdrop(event) {
    // Only close if clicking directly on the modal backdrop, not its children
    if (event.target === event.currentTarget) {
        closeEditModal();
    }
}

function toggleHabit(habitId, checkbox) {
    fetch(`/toggle-habit/${habitId}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        }
    })
    .then(response => {
        if (!response.ok) {
            // If the request failed, revert the checkbox
            checkbox.checked = !checkbox.checked;
            alert('Failed to update habit. Please try again.');
        } else {
            // Update the UI after successful toggle
            const countElement = document.querySelector('.detail-count-main');
            const dotGrid = document.querySelector('.detail-dot-grid');
            const firstDot = dotGrid.querySelector('.detail-dot:first-child');

            // Update the count
            let currentCount = parseInt(countElement.textContent);
            if (checkbox.checked) {
                countElement.textContent = currentCount + 1;
                firstDot.classList.add('filled');
            } else {
                countElement.textContent = currentCount - 1;
                firstDot.classList.remove('filled');
            }
        }
    })
    .catch(error => {
        // If there's an error, revert the checkbox
        checkbox.checked = !checkbox.checked;
        alert('Failed to update habit. Please try again.');
    });
}
</script>

<div class="detail-count-row">
    <div class="detail-count-display">
        <div class="count-wrapper">
            <span class="detail-count-main">{{ habit.count }}</span>
            <span class="detail-count-suffix">/100</span>
        </div>
    </div>

    <div class="detail-dot-grid">
        {% for day_completed in habit.history %}
        <div class="detail-dot {% if day_completed %}filled{% endif %}"></div>
        {% endfor %}
    </div>
</div>
</div>

<div class="trend-graph-container">
    <div class="trend-title">
        <select id="trendPeriod" class="trend-period-select" onchange="updateTrendPeriod({{ habit.habit_id }})">
            <option value="100" {% if habit.trend_period == 100 %}selected{% endif %}>100</option>
            <option value="200" {% if habit.trend_period == 200 %}selected{% endif %}>200</option>
            <option value="300" {% if habit.trend_period == 300 %}selected{% endif %}>300</option>
            <option value="365" {% if habit.trend_period == 365 %}selected{% endif %}>365</option>
            <option value="400" {% if habit.trend_period == 400 %}selected{% endif %}>400</option>
            <option value="500" {% if habit.trend_period == 500 %}selected{% endif %}>500</option>
        </select>
        <span class="trend-title-text">Day Trend</span>
    </div>
    <svg id="trendGraph" class="trend-graph" viewBox="-40 0 640 350" preserveAspectRatio="xMidYMid meet">
        <!-- Define gradient -->
        <defs>
            <linearGradient id="trendGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:white;stop-opacity:0.4" />
                <stop offset="100%" style="stop-color:white;stop-opacity:0" />
            </linearGradient>
        </defs>

        <!-- Y-axis line -->
        <line x1="0" y1="0" x2="0" y2="300" stroke="rgba(255,255,255,0.5)" stroke-width="4"/>

        <!-- X-axis line -->
        <line x1="0" y1="300" x2="600" y2="300" stroke="rgba(255,255,255,0.5)" stroke-width="4"/>

        <!-- Y-axis labels -->
        <text x="-10" y="20" fill="#ffffff" font-size="20" font-family="Lora, serif" text-anchor="end" opacity="0.7">100</text>
        <text x="-10" y="300" fill="#ffffff" font-size="20" font-family="Lora, serif" text-anchor="end" opacity="0.7">0</text>

        <!-- Gradient fill under trend line -->
        {% if habit.trend %}
        {% set x_scale = 600 / (habit.trend|length - 1) %}
        <polygon
            points="{% for value in habit.trend|reverse %}{{ loop.index0 * x_scale }},{{ 300 - (value * 3) }} {% endfor %}600,300 0,300"
            fill="url(#trendGradient)"
        />

        <!-- Trend line -->
        <polyline
            points="{% for value in habit.trend|reverse %}{{ loop.index0 * x_scale }},{{ 300 - (value * 3) }}{% if not loop.last %} {% endif %}{% endfor %}"
            fill="none"
            stroke="rgba(255,255,255,0.85)"
            stroke-width="3"
            stroke-linecap="butt"
            stroke-linejoin="round"
        />
        {% endif %}

        <!-- X-axis month labels -->
        {% for month_label in habit.month_labels %}
        <text x="{{ month_label.x }}" y="325" fill="#ffffff" font-size="16" font-family="Lora, serif" text-anchor="middle" opacity="0.7">{{ month_label.label }}</text>
        {% endfor %}
    </svg>
</div>

<script>
function updateTrendPeriod(habitId) {
    const period = document.getElementById('trendPeriod').value;
    window.location.href = `/habit/${habitId}?period=${period}`;
}
</script>
{% endblock %}
